# Examples

This document provides practical examples from the Sample.CommandLine project demonstrating various features of Albatross.CommandLine.

## Basic Program Setup

This example shows the essential structure of a console application using Albatross.CommandLine. It demonstrates how to configure the program entry point, set up dependency injection, and register both generated and manual commands.

```csharp
internal class Program {
    static Task<int> Main(string[] args) {
        var setup = new MySetup()
            // this method is generated by source generator
            .AddCommands();
        // this is a custom command added manually
        setup.CommandBuilder.AddWithParentKey("test", new ManualCommand());
        return setup.Parse(args).RegisterServices().Build().InvokeAsync();
    }
}

public class MySetup : Setup {
    public MySetup() : base("This a sample commandline program") {
    }

    protected override void RegisterServices(ParseResult result, IConfiguration configuration, EnvironmentSetting envSetting, IServiceCollection services) {
        base.RegisterServices(result, configuration, envSetting, services);
        services.AddShortenLoggerName(false, "Albatross", "Sample");
        // RegisterCommands method is generated by codegen
        services.RegisterCommands();
        // register your dependencies here
        services.AddSingleton<IMyService, MyService>();
        
        // conditional registration based on command
        var key = result.CommandResult.Command.GetCommandKey();
        if (key.StartsWith("csharp ")) {
            // register csharp command specific services
            services.AddSingleton<ICodeGenerator, CSharpCodeGenerator>();
        } else if (key.StartsWith("typescript ")) {
            // register typescript command specific services
            services.AddSingleton<ICodeGenerator, TypeScriptCodeGenerator>();
        }
    }
}
```

## HelloWorld Command with Arguments and Options

This comprehensive example demonstrates how to define commands with various types of arguments and options. It shows required vs optional parameters, nullability patterns, default values, and custom validation through partial class extension.

```csharp
[Verb<HelloWorldCommandAction>("hello", Description = "The HelloWorld command")]
public record class HelloWorldOptions {
    [Argument(Description = "The order of declaration determines the position of the argument")]
    public required string Argument1 { get; init; }

    [Argument(Description = "Optional arguments should be put after the required ones")]
    public string? Argument2 { get; init; }

    [Option(Description = "By default, nullability of the property is used to determine if the option is required")]
    public required string Name { get; init; }

    [Option(Description = "Same goes for the value types")]
    public required int Value { get; init; }

    [Option(Description = "But Required flag can be set to override the behavior", Required = false)]
    public decimal NumericValue { get; init; }

    [Option(DefaultToInitializer = true, Description = "Set DefautlToInitializer to true to use the property initializer as the default value.  If true, the option is not required.")]
    public DateOnly Date { get; init; } = DateOnly.FromDateTime(DateTime.Today);
}

/// <summary>
/// Customize the command behavior by implementing the partial method Initialize
/// </summary>
public partial class HelloWorldCommand {
    partial void Initialize() {
        this.Option_Date.Validators.Add(r => {
            var value = r.GetValue(this.Option_Date);
            if(value < DateOnly.FromDateTime(DateTime.Today)) {
                r.AddError($"Invalid value {value:yyyy-MM-dd} for Date.  It cannot be in the past");
            }
        });
    }
}

public class HelloWorldCommandAction : CommandAction<HelloWorldOptions> {
    public HelloWorldCommandAction(HelloWorldOptions options) : base(options) {
    }

    public override async Task<int> Invoke(CancellationToken cancellationToken) {
        await this.Writer.WriteLineAsync(options.ToString());
        return 0;
    }
}
```

## Service Injection Example

This example illustrates dependency injection in command actions. It shows how to inject custom services into command handlers and use them within the command execution logic.

```csharp
[Verb<TestServiceInjectionCommandAction>("test service-injection", Description = "This verb demonstrats the use of service injection in command actions")]
public record class TestServiceInjectionOptions {
    [Option]
    public required string TextValue { get; init; }
}

public class TestServiceInjectionCommandAction : CommandAction<TestServiceInjectionOptions> {
    private readonly IMyService myService;
    
    public TestServiceInjectionCommandAction(IMyService myService, TestServiceInjectionOptions options) : base(options) {
        this.myService = myService;
    }
    
    public override async Task<int> Invoke(CancellationToken cancellationToken) {
        var text = await this.myService.DoSomething();
        await this.Writer.WriteLineAsync(text);
        await this.Writer.WriteLineAsync(this.options.ToString());
        return 0;
    }
}

public interface IMyService {
    Task<string> DoSomething();
}

public class MyService : IMyService {
    public Task<string> DoSomething() {
        return Task.FromResult("Hello World!");
    }
}
```

## Arguments Examples

These examples demonstrate different types of command arguments: required arguments, optional (nullable) arguments, and array arguments with arity constraints. Arguments are positional parameters that don't require option flags.

```csharp
// Basic arguments
[Verb<DefaultCommandAction<TestArgumentsOptions>>("test arguments", Description = "A command to test arguments parsing")]
public record class TestArgumentsOptions {
    [Argument(Description = "A required string argument")]
    public required string StringArg { get; init; }

    [Argument(Description = "A required integer argument")]
    public required int IntArg { get; init; }
    
    [Argument(Description = "An optional date argument")]
    public DateOnly? DateArg { get; init; }
}

// Nullable arguments
[Verb<DefaultCommandAction<TestNullableArguments>>("test nullable-arguments", Description = "Optional arguments should be placed after the required arguments")]
public record class TestNullableArguments {
    [Argument(Description = "Required string value")]
    public required string RequiredStringValue { get; init; }

    [Argument(Description = "Nullable string argument")]
    public string? NullableStringArgument { get; init; }
}

// Array arguments with arity
[Verb<DefaultCommandAction<TestArgumentRequiredArrayInputOptions>>("test argument-required-array", Description = "Test argument required arity for multiple values")]
public record class TestArgumentRequiredArrayInputOptions {
    [Argument(ArityMin = 1, ArityMax = 10, Description = "Int collections with a count between 1 and 10")]
    public int[] IntValues { get; init; } = Array.Empty<int>();
}
```

## Option Examples

These examples show various option configurations including required flags, collections, boolean options, and how the `Required` attribute can override default nullability behavior.

```csharp
// Required flag options
[Verb<DefaultCommandAction<TestOptionRequiredFlagOptions>>("test option-required-flag", Description = "By default, nullable value, collection and booleans are not required.  But Required flag can be used to overwritten")]
public record class TestOptionRequiredFlagOptions {
    [Option(Required = true, Description = "Collection with required flag")]
    public required int[] IntValues { get; init; }

    [Option(Description = "Optional collection")]
    public string[] TextValues { get; set; } = [];

    [Option(Description = "Default optional boolean flag")]
    public bool OptionalBoolValue { get; init; }

    [Option(Required = true, Description = "Required boolean flag")]
    public bool RequiredBoolValue { get; init; }

    [Option(Description = "Required text value")]
    public required string RequiredTextValue { get; init; }

    [Option(Description = "Optional text value")]
    public string? OptionalTextValue { get; init; }

    [Option(Required = false, Description = "Non Nullable struct value with Required = false")]
    public int OptionalIntValue { get; init; }
}

// Nullable options
[Verb<DefaultCommandAction<TestNullableOptions>>("test nullable", Description = "A command to test nullable options")]
public record class TestNullableOptions {
    [Option(Description = "A nullable string")]
    public string? NullableString { get; init; }

    [Option(Description = "A nullable integer")]
    public int? NullableInt { get; init; }

    [Option(Description = "A nullable array")]
    public int[]? NullableArray { get; init; }
}
```

## Default Values Example

This example shows how to use property initializers as default values for options by setting `DefaultToInitializer = true`. This makes the options optional with predefined default values.

```csharp
[Verb<DefaultCommandAction<TestDefaultValuesOptions>>("test defaults", Description = "Test setting of default values")]
public record class TestDefaultValuesOptions {
    [Option(DefaultToInitializer = true)]
    public int IntValue { get; init; } = 42;

    [Option(DefaultToInitializer = true)]
    public string StringValue { get; init; } = "Hello, World!";

    [Option(DefaultToInitializer = true)]
    public bool BoolValue { get; init; } = true;

    [Option(DefaultToInitializer = true)]
    public DateOnly Date { get; init; } = DateOnly.FromDateTime(DateTime.Today);

    [Option(DefaultToInitializer = true)]
    public ShadesOfGray ShadesOfGray { get; init; } = ShadesOfGray.LightGray;
}
```

## Enum Values Example

This example demonstrates how to use enum types as both arguments and options. The command line parser automatically handles enum value parsing and provides helpful error messages for invalid values.

```csharp
[Verb<DefaultCommandAction<TestEnumValueOptions>>("test enum", Description = "Test use of enum value as arguments and options")]
public record class TestEnumValueOptions {
    [Argument(Description = "First required shade of gray")]
    public ShadesOfGray Gray1 { get; init; }

    [Option(Description = "Second required shade of gray")]
    public ShadesOfGray Gray2 { get; init; }

    [Option(Description = "Third optional shade of gray")]
    public ShadesOfGray? Gray3 { get; init; }
}
```

## Command Aliases Example

This example shows how to define command aliases using the `Alias` property. Users can invoke the command using any of the defined aliases for convenience.

```csharp
[Verb<DefaultCommandAction<TestCommandAliasesOptions>>("test command-aliases", Alias = ["a", "cmd-alias"], Description = "Test the use of command aliases")]
public record class TestCommandAliasesOptions {
}
```

## Hidden Arguments and Options

This example demonstrates how to create hidden parameters that are available for use but don't appear in help text. This is useful for advanced or internal options that shouldn't clutter the help output.

```csharp
[Verb<DefaultCommandAction<TestHiddenPropertiesOptions>>("test hidden", Description = "Test hidden arguments and options: --hidden-string-value, --hidden-int-value")]
public record class TestHiddenPropertiesOptions {
    [Argument(Description = "A string value")]
    public required string StringValue { get; init; }

    [Argument(Description = "A hidden argument value", Hidden = true)]
    public string? HiddenStringValue { get; init; }

    [Option(Description = "A int value")]
    public required int IntValue { get; init; }

    [Option(Description = "A hidden int value", Hidden = true)]
    public int? HiddenIntValue { get; init; }

    /// <summary>
    /// This value should be ignored since it is not annotated with Argument or Option
    /// </summary>
    public DateOnly IgnoredValue { get; init; }
}
```

## Mutually Exclusive Commands with Base Classes

This example shows how to create mutually exclusive commands that share common options through inheritance. The `UseBaseOptionsClass` attribute and base class inheritance allow for clean option sharing between related commands.

```csharp
[Verb<ExampleProjectCommandAction>("example project echo", UseBaseOptionsClass = typeof(SharedProjectOptions), Description = "This demonstrates the use of mutually exclusive commands using inheritance.")]
public record class ProjectEchoOptions : SharedProjectOptions {
    [Option]
    public required int Echo { get; init; }
}

[Verb<ExampleProjectCommandAction>("example project fubar", UseBaseOptionsClass = typeof(SharedProjectOptions), Description = "This demonstrates the use of mutually exclusive commands using inheritance.")]
public record class ProjectFubarOptions : SharedProjectOptions {
    [Option]
    public required int Fubar { get; init; }
}

public record class SharedProjectOptions {
    [Option]
    public required int Id { get; init; }
}

public class ExampleProjectCommandAction : CommandAction<SharedProjectOptions> {
    public ExampleProjectCommandAction(SharedProjectOptions options) : base(options) {
    }

    public override Task<int> Invoke(CancellationToken cancellationToken) {
        if (options is ProjectEchoOptions echoOptions) {
            this.Writer.WriteLine($"Invoked project echo: {echoOptions}");
        } else if (options is ProjectFubarOptions fubarOptions) {
            this.Writer.WriteLine($"Invoked project fubar: {fubarOptions}");
        } else {
            throw new NotSupportedException($"Unsupported options: {options}");
        }
        return Task.FromResult(0);
    }
}
```

## Command-Specific Service Registration

This example demonstrates advanced service registration patterns where different services are registered based on the command being executed. This allows for command-specific implementations while maintaining clean dependency injection.

```csharp
[Verb<ExampleCommandSpecificRegistrationsAction>("example csharp web-client")]
[Verb<ExampleCommandSpecificRegistrationsAction>("example typescript web-client")]
public record class ExampleCommandSpecificRegistrationsOptions {
    [Option(Description = "Output directory for generated C# files")]
    public required DirectoryInfo OutputDirectory { get; init; }

    [Option(Description = "Project file path")]
    public required FileInfo Project { get; init; }
}

public class ExampleCommandSpecificRegistrationsAction : CommandAction<ExampleCommandSpecificRegistrationsOptions> {
    private readonly ICodeGenerator codeGenerator;
    
    public ExampleCommandSpecificRegistrationsAction(ICodeGenerator codeGenerator, ExampleCommandSpecificRegistrationsOptions options) : base(options) {
        this.codeGenerator = codeGenerator;
    }
    
    public override Task<int> Invoke(CancellationToken cancellationToken) {
        this.Writer.WriteLine(this.codeGenerator.Generate(this.options));
        return Task.FromResult(0);
    }
}

public interface ICodeGenerator {
    string Generate(ExampleCommandSpecificRegistrationsOptions options);
}

public class CSharpCodeGenerator : ICodeGenerator {
    public string Generate(ExampleCommandSpecificRegistrationsOptions options) {
        return $"generating c# code: {options}";
    }
}

public class TypeScriptCodeGenerator : ICodeGenerator {
    public string Generate(ExampleCommandSpecificRegistrationsOptions options) {
        return $"type script: {options}";
    }
}
```

## Manual Command Creation

This example shows how to create commands manually without using code generation. This approach gives you full control over the command definition and is useful for complex scenarios or when you need to integrate existing System.CommandLine code.

```csharp
public class ManualCommand : Command {
    public ManualCommand() : base("manual-command", "This command is created manually") {
        Add(TextArgument);
        Add(NameOption);
        SetAction(Invoke);
    }

    public Argument<string> TextArgument { get; } = new Argument<string>("text") {
        DefaultValueFactory = (_) => "default text",
    };

    public Option<string> NameOption { get; } = new Option<string>("--name") {
        Description = "Name option for the manual command",
        Required = true,
    };

    int Invoke(ParseResult result) {
        var name = result.GetRequiredValue(NameOption);
        Console.Out.WriteLine($"ManualCommand invoked with name: {name}");
        return 0;
    }
}
```

## Command Customization

This example demonstrates how to customize generated commands by extending their partial classes. You can add custom validation logic, modify option behavior, or extend functionality while still benefiting from code generation.

```csharp
[Verb<DefaultCommandAction<TestCustomizedCommandOptions>>("test customized", Description = "Commands can be customized by extending its partial class")]
public record class TestCustomizedCommandOptions {
    [Option("d")]
    public required string Description { get; init; }
}

public partial class TestCustomizedCommand {
    partial void Initialize() {
        this.Option_Description.Validators.Add(r => {
            var text = r.GetRequiredValue(this.Option_Description);
            if (text.Length < 3) {
                r.AddError("Description must be at least 3 characters long.");
            }
        });
    }
}
```

## Inheritance from Base Classes

This example shows how option classes can inherit from base classes to share common properties. The code generator prioritizes properties declared on the current class over inherited ones when determining option order.

```csharp
public record class BaseOptions1 : BaseOptions2 {
    [Option(Description = "Output directory for generated C# files")]
    public required DirectoryInfo OutputDirectory { get; init; }
}

public record class BaseOptions2 {
    [Option(Description = "Project file path")]
    public required FileInfo Project { get; init; }
}

[Verb<DefaultCommandAction<TestBaseClassPropertiesOptions>>("test base-class-properties", Description = "When determining option property order, the code generator prioritizes properties declared on the current class over those inherited from base classes.")]
public record class TestBaseClassPropertiesOptions : BaseOptions1 {
    [Option(Description = "C# language version")]
    public required string LanguageVersion { get; init; }
}
```

## Parent Commands

This example demonstrates how to create parent commands that group related subcommands. Parent commands can be defined explicitly or created automatically when undefined parent commands are referenced in command paths.

```csharp
[Verb("test", Description = "A series of test commands to verify the functionalities")]
[Verb("example", Description = "A series of examples of varies use cases")]
public record class ParentOptions {
}

[Verb<DefaultCommandAction<TestUndefinedParentCommandOptions>>("p1 p2 new", Description = "The parent command project is not defined explicitly.  It will be created automatically.")]
public record class TestUndefinedParentCommandOptions {
}
```
