# Code Generator

Albatross.CommandLine.CodeGen is an incremental source generator that automatically creates command classes, service registrations, and extension methods from attributed options classes. This eliminates boilerplate code while maintaining full flexibility.

## How Code Generation Works

The code generator uses Roslyn's incremental source generation capabilities to scan your code at compile time, find classes annotated with `[VerbAttribute]`, and generate the necessary System.CommandLine infrastructure.

### Architecture Overview

The code generation process follows these steps:

1. **Attribute Discovery**: The generator scans for `[VerbAttribute]` annotations on classes and assemblies
2. **Command Setup Creation**: For each found attribute, it creates a `CommandSetup` object containing metadata
3. **Code Generation**: The setup objects are used to generate command classes and service registrations
4. **Source Addition**: Generated code is added to the compilation as additional source files

### Supported Attribute Patterns

The generator recognizes three patterns of `[VerbAttribute]` usage:

```csharp
// Pattern 1: Basic verb without handler (uses DefaultCommandAction)
[Verb("command-name")]
public record class BasicOptions { }

// Pattern 2: Verb with typed handler
[Verb<MyCommandAction>("command-name")]
public record class TypedOptions { }

// Pattern 3: Assembly-level verb with both options and handler types
[assembly: Verb<MyOptions, MyCommandAction>("command-name")]
```

### Command Setup Process

For each discovered `[VerbAttribute]`, the generator creates a `CommandSetup` object that contains:

- **Command Key**: The command name/path from the attribute parameter
- **Command Name**: The last segment of the command key (for sub-commands)
- **Options Class**: The target class or type specified in assembly-level attributes
- **Handler Class**: The command action type (if specified)
- **Command Class Name**: Generated by removing "Options" suffix and adding "Command"
- **Properties**: All properties annotated with `[Option]` or `[Argument]`
- **Metadata**: Description, aliases, and other attribute properties

### Property Analysis

The generator analyzes each property in the options class to determine:

```csharp
public record class ExampleOptions {
    // Required - non-nullable reference type
    public required string Name { get; init; }
    
    // Optional - nullable reference type
    public string? Description { get; init; }
    
    // Argument - positional parameter
    [Argument]
    public required string InputFile { get; init; }
    
    // Option with custom configuration
    [Option("v", "verbose", Description = "Enable verbose output")]
    public bool Verbose { get; init; }
    
    // Default value from initializer
    [Option(DefaultToInitializer = true)]
    public int Count { get; init; } = 10;
}
```

For each property, the generator determines:
- **Parameter Type**: Option or Argument based on attributes
- **Requirement**: Based on nullability and `Required` attribute
- **Name**: Kebab-cased property name or explicit alias from attribute parameters
- **Default Value**: Using `DefaultValueFactory` when `DefaultToInitializer = true`
- **Arity**: For arguments, determines how many values are expected using `ArgumentArity`
- **Validation**: Hidden status and other constraints

The service registration uses the `IOptions<T>` pattern for dependency injection, creating option instances by extracting values from the `ParseResult` using either `GetRequiredValue<T>()` for required parameters or `GetValue<T>()` for optional ones.

### Generated Property Names

Within the command class, option and argument properties are generated with specific prefixes:
- **Options**: `Option_PropertyName` (e.g., `Option_Name`, `Option_Date`)
- **Arguments**: `Argument_PropertyName` (e.g., `Argument_StringArg`, `Argument_InputFile`)

Argument names in the command line are kebab-cased versions of property names, while option names get the standard `--` prefix for full names and `-` prefix for single-character aliases.

### Generated Command Classes

For each command setup, the generator creates a partial command class:

```csharp
// Generated from HelloWorldOptions
using System.CommandLine;
#nullable enable
namespace Sample.CommandLine {
    public sealed partial class HelloWorldCommand : Command {
        public HelloWorldCommand() : base("hello", "HelloWorld command") {
            this.Option_Name = new Option<string>("--name", "-n") {
                Description = "Give me a name",
                Required = true,
            };
            this.Add(this.Option_Name);
            
            this.Option_Date = new Option<System.Nullable<System.DateOnly>>("--date", "-d") {
                Description = "Give me an optional date",
            };
            this.Add(this.Option_Date);
            
            this.Option_Number = new Option<int>("--number", "-x") {
                Description = "Give me a number",
                DefaultValueFactory = _ => 100,
            };
            this.Add(this.Option_Number);
            
            // Customization hook
            this.Initialize();
        }
        
        public Option<string> Option_Name { get; }
        public Option<System.Nullable<System.DateOnly>> Option_Date { get; }
        public Option<int> Option_Number { get; }
        
        // Partial method for customization
        partial void Initialize();
    }
}
```

For commands with arguments:

```csharp
// Generated from TestArgumentsOptions
public sealed partial class TestArgumentsCommand : Command {
    public TestArgumentsCommand() : base("arguments", "A command to test arguments parsing") {
        this.Argument_StringArg = new Argument<string>("string-arg") {
            Description = "A required string argument",
            Arity = new ArgumentArity(1, 1),
        };
        this.Add(this.Argument_StringArg);
        
        this.Argument_DateArg = new Argument<System.Nullable<System.DateOnly>>("date-arg") {
            Description = "An optional date argument",
            Arity = new ArgumentArity(0, 1),
        };
        this.Add(this.Argument_DateArg);
        
        this.Initialize();
    }
    
    public Argument<string> Argument_StringArg { get; }
    public Argument<System.Nullable<System.DateOnly>> Argument_DateArg { get; }
    
    partial void Initialize();
}
```

### Service Registration Generation

The generator creates a `CodeGenExtensions` class with methods for dependency injection:

```csharp
using Albatross.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using System.CommandLine;

public static class CodeGenExtensions {
    public static IServiceCollection RegisterCommands(this IServiceCollection services) {
        // Register command actions with keys
        services.AddKeyedScoped<ICommandAction, Sample.CommandLine.HelloWorldCommandAction>("hello");
        
        // Register options binding with IOptions<T> pattern
        services.AddScoped<IOptions<Sample.CommandLine.HelloWorldOptions>>(provider => {
            var result = provider.GetRequiredService<ParseResult>();
            var options = new Sample.CommandLine.HelloWorldOptions() {
                Name = result.GetRequiredValue<string>("--name"),
                Date = result.GetValue<System.Nullable<System.DateOnly>>("--date"),
                Number = result.GetRequiredValue<int>("--number"),
            };
            return Options.Create(options);
        });
        
        // Register argument-based commands
        services.AddKeyedScoped<ICommandAction, DefaultCommandAction<TestArgumentsOptions>>("test arguments");
        services.AddScoped<IOptions<Sample.CommandLine.TestArgumentsOptions>>(provider => {
            var result = provider.GetRequiredService<ParseResult>();
            var options = new Sample.CommandLine.TestArgumentsOptions() {
                StringArg = result.GetRequiredValue<string>("string-arg"),
                IntArg = result.GetRequiredValue<int>("int-arg"),
                DateArg = result.GetValue<System.Nullable<System.DateOnly>>("date-arg"),
            };
            return Options.Create(options);
        });
        
        return services;
    }
    
    public static Setup AddCommands(this Setup setup) {
        setup.CommandBuilder.Add<HelloWorldCommand>("hello");
        setup.CommandBuilder.Add<TestArgumentsCommand>("test arguments");
        setup.CommandBuilder.Add<TestCustomizedCommand>("test customized");
        setup.CommandBuilder.Add<TestUndefinedParentCommand>("p1 p2 new");
        return setup;
    }
}
```

### Generated Property Names

Within the command class, option and argument properties are generated with specific prefixes:
- **Options**: `Option_PropertyName` (e.g., `Option_Name`, `Option_Date`)
- **Arguments**: `Argument_PropertyName` (e.g., `Argument_StringArg`, `Argument_InputFile`)

Argument names in the command line are kebab-cased versions of property names, while option names get the standard `--` prefix for full names and `-` prefix for single-character aliases.

### Command Naming and Conflict Resolution

The generator follows specific naming conventions:

1. **Remove Options Suffix**: `BackupOptions` → `Backup`
2. **Add Command Suffix**: `Backup` → `BackupCommand`
3. **Handle Conflicts**: Multiple classes with same generated name get numbered suffixes

```csharp
// These would create naming conflicts:
public class BackupOptions { }        // → BackupCommand
public class BackupCommandOptions { } // → BackupCommand1

// Avoid conflicts by using distinctive names
public class FileBackupOptions { }    // → FileBackupCommand
public class DatabaseBackupOptions { } // → DatabaseBackupCommand
```

### Incremental Generation Features

The generator uses incremental compilation for performance:

- **Attribute Targeting**: Only processes classes/assemblies with `[VerbAttribute]`
- **Change Detection**: Regenerates only when attribute usage changes
- **Parallel Processing**: Multiple command setups processed concurrently
- **Caching**: Compilation and symbol information cached between builds

### Debug Output

For troubleshooting, you can enable debug file generation:

```xml
<PropertyGroup>
    <EmitAlbatrossCodeGenDebugFile>true</EmitAlbatrossCodeGenDebugFile>
</PropertyGroup>
<ItemGroup>
    <CompilerVisibleProperty Include="EmitAlbatrossCodeGenDebugFile" />
</ItemGroup>
```

This creates `albatross-commandline-codegen.debug.txt` with generated source code.

### Advanced Features

#### Assembly-Level Commands

Commands can be defined at assembly level for cross-assembly scenarios:

```csharp
[assembly: Verb<SharedOptions, SharedCommandAction>("shared-command")]

public record class SharedOptions {
    [Option]
    public required string Value { get; init; }
}

public class SharedCommandAction : CommandAction<SharedOptions> {
    // Implementation
}
```

#### Base Options Classes

Commands can share common options through inheritance:

```csharp
[Verb<ProjectEchoAction>("project echo", UseBaseOptionsClass = typeof(ProjectOptions))]
public record class EchoOptions : ProjectOptions {
    [Option]
    public required string Message { get; init; }
}

[Verb<ProjectListAction>("project list", UseBaseOptionsClass = typeof(ProjectOptions))]  
public record class ListOptions : ProjectOptions {
    [Option]
    public bool Detailed { get; init; }
}

public record class ProjectOptions {
    [Option]
    public required string ProjectPath { get; init; }
}
```

#### Command Hierarchies

Sub-commands are created automatically from space-separated command keys:

```csharp
[Verb<DatabaseBackupAction>("database backup")]
public record class DatabaseBackupOptions { }

[Verb<DatabaseRestoreAction>("database restore")]
public record class DatabaseRestoreOptions { }

// Creates:
// - DatabaseCommand (parent)
// - DatabaseBackupCommand (child)
// - DatabaseRestoreCommand (child)
```

### Error Handling

The generator provides diagnostic messages for common issues:

- **Missing Handler**: Warning when no command action is specified
- **Invalid Types**: Error when handler doesn't implement `ICommandAction`
- **Naming Conflicts**: Warning when multiple commands have same generated name
- **Invalid Properties**: Error when properties can't be converted to options/arguments

### Integration with System.CommandLine

Generated commands are full System.CommandLine `Command` instances with:

- **Standard Features**: Options, arguments, validators, completions
- **Dependency Injection**: Automatic service registration and resolution  
- **Customization**: Partial class extension points for advanced scenarios
- **Validation**: Built-in and custom validation support
- **Help Generation**: Automatic help text from descriptions

This comprehensive code generation system eliminates boilerplate while preserving the full power and flexibility of System.CommandLine.
