# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build and Test Commands

```bash
# Build entire solution
dotnet build commandline.sln

# Build specific project
dotnet build Albatross.CommandLine/Albatross.CommandLine.csproj

# Run tests
dotnet test Albatross.CommandLine.Test

# Run a single test
dotnet test Albatross.CommandLine.Test --filter "FullyQualifiedName~TestCommandBuilder.TestParseCommandText"

# Run sample application
dotnet run --project Sample.CommandLine -- <command> [options]

# Pack NuGet packages
dotnet pack commandline.sln -c Release
```

## Project Architecture

This is a .NET library that simplifies creating command-line applications on top of `System.CommandLine`. It uses Roslyn source generators for AOT-compatible code generation.

### Projects

- **Albatross.CommandLine** - Core library with `CommandHost`, attributes (`[Verb]`, `[Option]`, `[Argument]`), and `IAsyncCommandHandler` interface. Targets .NET Standard 2.1.
- **Albatross.CommandLine.CodeGen** - Roslyn incremental source generator that generates command classes, DI registration (`RegisterCommands()`), and command wiring (`AddCommands()`) from `[Verb]` attributes.
- **Albatross.CommandLine.Defaults** - Optional package adding Serilog logging and JSON configuration via `.WithDefaults()`.
- **Albatross.CommandLine.Inputs** - Reusable `Option` and `Argument` types for file/directory inputs with validation.
- **Albatross.CommandLine.Test** - Unit tests using xUnit.
- **Sample.CommandLine** - Example application demonstrating all features.

### Key Patterns

**Command Definition**: Commands are defined by applying `[Verb<THandler>]` to a parameters record class:
```csharp
[Verb<HelloWorldCommandHandler>("hello", Description = "The HelloWorld command")]
public record class HelloWorldParams {
    [Option]
    public required string Name { get; init; }
}
```

**Command Handler**: Handlers implement `IAsyncCommandHandler`:
```csharp
public class HelloWorldCommandHandler : IAsyncCommandHandler {
    public Task<int> InvokeAsync(CancellationToken cancellationToken) { ... }
}
```

**Bootstrap Pattern** (`Program.cs`):
```csharp
await using var host = new CommandHost("App Name")
    .RegisterServices(RegisterServices)
    .AddCommands()      // generated by source generator
    .Parse(args)
    .WithDefaults()     // optional: adds config + logging
    .Build();
return await host.InvokeAsync();
```

### Source Generator Output

The code generator produces:
1. `{CommandName}Command.g.cs` - Partial command classes with options/arguments
2. `CodeGenExtensions.g.cs` - Contains `RegisterCommands()` for DI and `AddCommands()` for command hierarchy

To view generated files, add to project:
```xml
<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
```

### Key Attributes (in `Albatross.CommandLine.Annotations`)

- `[Verb<THandler>("name")]` - Defines a command with handler type
- `[Verb<TParams, THandler>("name")]` - Assembly-level verb (no dedicated params class needed)
- `[Option("alias")]` - Marks property as named option
- `[Argument]` - Marks property as positional argument
- `[UseOption<T>]` / `[UseArgument<T>]` - Compose reusable option/argument types
- `[OptionHandler<TOption, THandler>]` - Injectable async option pre-processing

### Subcommand Hierarchy

Commands with spaces create hierarchies: `[Verb("config set")]` creates `config` parent with `set` child.

## Documentation

Full documentation: https://rushuiguan.github.io/commandline/
